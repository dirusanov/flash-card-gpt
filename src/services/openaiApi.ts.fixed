import { OpenAI } from 'openai';
import { getGlobalApiTracker } from './apiTracker';

// Simple cache to prevent API spam when quota is exceeded
let quotaExceededCache: { timestamp: number; message: string; notificationShown: boolean } | null = null;
const QUOTA_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Check if we recently got a quota exceeded error
export const isQuotaExceededCached = (): boolean => {
  if (!quotaExceededCache) return false;
  
  const now = Date.now();
  if (now - quotaExceededCache.timestamp > QUOTA_CACHE_DURATION) {
    quotaExceededCache = null;
    return false;
  }
  
  return true;
};

// Cache quota exceeded error
export const cacheQuotaExceededError = (message: string): void => {
  quotaExceededCache = {
    timestamp: Date.now(),
    message,
    notificationShown: false
  };
};

export const markQuotaNotificationShown = (): void => {
  if (quotaExceededCache) {
    quotaExceededCache.notificationShown = true;
  }
};

export const shouldShowQuotaNotification = (): boolean => {
  return quotaExceededCache !== null && !quotaExceededCache.notificationShown;
};

// Get cached quota error message
export const getCachedQuotaError = (): string | null => {
  return quotaExceededCache?.message || null;
};

// –•–µ–ª–ø–µ—Ä-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–∞—Ö –æ—Ç OpenAI
const formatOpenAIErrorMessage = (errorData: any): string => {
  if (!errorData || !errorData.error) {
    return "Unknown OpenAI API error";
  }
  
  const { message, type, code } = errorData.error;
  
  let formattedMessage = "";
  
  // –û—Å–Ω–æ–≤–Ω–∞—è —á–∞—Å—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ
  if (code === "insufficient_quota") {
    formattedMessage = "Your OpenAI account has exceeded its quota.\n\nPlease check your billing details or use a different API key.";
  } else if (type === "invalid_request_error") {
    formattedMessage = "Invalid request to OpenAI.\n\nPlease check your API key and settings.";
  } else if (type === "rate_limit_exceeded") {
    formattedMessage = "OpenAI rate limit exceeded.\n\nPlease try again in a few minutes.";
  } else {
    formattedMessage = `OpenAI API Error: ${message || "Unknown error"}`;
  }
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏ (–¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤)
  formattedMessage += `\n\nDetails:\n- Type: ${type || "unknown"}\n- Code: ${code || "none"}`;
  
  return formattedMessage;
};

export const translateText = async (
  apiKey: string,
  text: string,
  translateToLanguage: string = 'ru',
  customPrompt: string = '',
  abortSignal?: AbortSignal
): Promise<string | null> => {
  // Track API request
  const tracker = getGlobalApiTracker();
  const requestId = tracker.startRequest(
    'translate',
    `Translating text to ${translateToLanguage}`,
    'üåç',
    '#3B82F6'
  );

  try {
    if (!apiKey) {
      tracker.errorRequest(requestId);
      throw new Error("OpenAI API key is missing. Please check your settings.");
    }

    // Mark as in progress
    tracker.setInProgress(requestId);

    // Check if we recently got a quota exceeded error
    if (isQuotaExceededCached()) {
      tracker.errorRequest(requestId);
      throw new Error(quotaExceededCache!.message);
    }

    const basePrompt = `Translate the following text to ${translateToLanguage}`;

    const systemPrompt = customPrompt
      ? `${basePrompt}. ${customPrompt}`
      : basePrompt;
    
    const body = {
      model: 'gpt-5-nano',
      messages: [
        {
          role: 'system',
          content: systemPrompt,
        },
        { role: 'user', content: `${text}` },
      ],

    };

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify(body),
      signal: abortSignal,
    });

    if (!response.ok) {
      const errorData = await response.json();
      if (errorData && errorData.error) {
        const errorMessage = formatOpenAIErrorMessage(errorData);
        
        // Cache quota exceeded errors to prevent spam
        if (errorData.error.code === 'insufficient_quota' || response.status === 429) {
          cacheQuotaExceededError(errorMessage);
        }
        
        throw new Error(errorMessage);
      }
      throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    tracker.completeRequest(requestId);
    return data.choices[0]?.message?.content?.trim() ?? null;
  } catch (error) {
    console.error('Error during translation:', error);
    tracker.errorRequest(requestId);
    throw error; // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤–≤–µ—Ä—Ö, —á—Ç–æ–±—ã –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –º–æ–≥ –µ–µ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å
  }
};

export const getExamples = async (
  apiKey: string,
  word: string,
  translateToLanguage: string,
  translate: boolean = false,
  customPrompt: string = '',
  abortSignal?: AbortSignal
): Promise<Array<[string, string | null]>> => {
  // Track API request
  const tracker = getGlobalApiTracker();
  const requestId = tracker.startRequest(
    'generate-examples',
    `Generating examples for "${word}"`,
    'üí°',
    '#F59E0B'
  );

  try {
    if (!apiKey) {
      tracker.errorRequest(requestId);
      throw new Error("OpenAI API key is missing. Please check your settings.");
    }

    tracker.setInProgress(requestId);

    // Check if we recently got a quota exceeded error
    if (isQuotaExceededCached()) {
      tracker.errorRequest(requestId);
      throw new Error(quotaExceededCache!.message);
    }

  const processedCustomPrompt = customPrompt.replace(/\{word\}/g, word);
  
  const basePrompt = `Give me three example sentences using the word '${word}' in the original language (the language of this word). 
Each example should show natural usage of '${word}' in its native language context.
Return ONLY the examples, one per line, without any numbering, explanations, or translations.`;
  
  const systemPrompt = customPrompt 
    ? `${basePrompt} ${processedCustomPrompt}` 
    : basePrompt;
  
  const promptMessages = [
    {
      role: 'system',
      content: systemPrompt,
    },
  ];

  const body = {
    model: 'gpt-5-nano',
    messages: promptMessages,

  };

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify(body),
    signal: abortSignal,
  });

    if (!response.ok) {
      const errorData = await response.json();
      if (errorData && errorData.error) {
        const errorMessage = formatOpenAIErrorMessage(errorData);
        
        // Cache quota exceeded errors to prevent spam
        if (errorData.error.code === 'insufficient_quota' || response.status === 429) {
          cacheQuotaExceededError(errorMessage);
        }
        
        throw new Error(errorMessage);
      }
      throw new Error(`Could not generate examples. OpenAI API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const resultText = data.choices[0]?.message?.content;
    const examples = resultText?.trim().split('\n') ?? [];

    const resultExamples: Array<[string, string | null]> = [];

    for (const example of examples) {
      if (!example.trim()) continue; // Skip empty lines
      
      let translatedExample: string | null = null;

      if (translate) {
        try {
          translatedExample = await translateText(
            apiKey,
            example,
            translateToLanguage
          );
        } catch (translationError) {
          console.error('Error translating example:', translationError);
          // –ï—Å–ª–∏ –ø–µ—Ä–µ–≤–æ–¥ –Ω–µ —É–¥–∞–ª—Å—è, –æ—Å—Ç–∞–≤–ª—è–µ–º null
        } finally {
          // Ensure we don't break the parsing
        }
      }

      resultExamples.push([example, translatedExample]);
    }

    if (resultExamples.length === 0) {
      tracker.errorRequest(requestId);
      throw new Error("Could not generate examples. Please try again with a different word or check your API key.");
    }

    tracker.completeRequest(requestId);
    return resultExamples;
  } catch (error) {
    console.error('Error during getting examples:', error);
    tracker.errorRequest(requestId);
    throw error; // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –≤–≤–µ—Ä—Ö, —á—Ç–æ–±—ã –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –º–æ–≥ –µ–µ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å
  }
};

export const isAbstract = async (
  apiKey: string,
  word: string
): Promise<boolean> => {
  // Track API request
  const tracker = getGlobalApiTracker();
  const requestId = tracker.startRequest(
    'analyze-word',
    `Analyzing if "${word}" is abstract or concrete`,
    'üîç',
    '#8B5CF6'
  );

  try {
    if (!apiKey) {
      tracker.errorRequest(requestId);
      throw new Error("OpenAI API key is missing. Please check your settings.");
    }

    tracker.setInProgress(requestId);

    // Check if we recently got a quota exceeded error
    if (isQuotaExceededCached()) {
      tracker.errorRequest(requestId);
      throw new Error(quotaExceededCache!.message);
    }

  const promptMessages = [
    {
      role: 'system',
      content: `Is the word '${word}' an abstract concept or a concrete object? Answer 'abstract' or 'concrete':`,
    },
  ];

  const body = {
    model: 'gpt-5-nano',
    messages: promptMessages,

  };

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify(body),
    signal: undefined, // AbortSignal not available in this function
  });

    if (!response.ok) {
      const errorData = await response.json();
      if (errorData && errorData.error) {
        const errorMessage = formatOpenAIErrorMessage(errorData);
        
        // Cache quota exceeded errors to prevent spam
        if (errorData.error.code === 'insufficient_quota' || response.status === 429) {
          cacheQuotaExceededError(errorMessage);
        }
        
        throw new Error(errorMessage);
      }
      throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const answer =
      data.choices[0]?.message?.content?.trim().toLowerCase() ?? '';
    tracker.completeRequest(requestId);
    return answer === 'abstract';
  } catch (error) {
    console.error('Error during determining abstractness:', error);
    tracker.errorRequest(requestId);
    // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –æ–±—ä–µ–∫—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π, –µ—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å
    return false;
  }
};

export const getDescriptionImage = async (
  apiKey: string,
  word: string,
  customInstructions: string = '',
  abortSignal?: AbortSignal
): Promise<string> => {
  // Track API request
  const tracker = getGlobalApiTracker();
  const requestId = tracker.startRequest(
    'create-image-description',
    `Creating image description for "${word}"`,
    'üé®',
    '#EC4899'
  );

  try {
    if (!apiKey) {
      tracker.errorRequest(requestId);
      throw new Error("OpenAI API key is missing. Please check your settings.");
    }

    tracker.setInProgress(requestId);

    // Check if we recently got a quota exceeded error
    if (isQuotaExceededCached()) {
      tracker.errorRequest(requestId);
      throw new Error(quotaExceededCache!.message);
    }

  const basePrompt = `Provide a detailed description for an image that represents the concept of '${word}'`;
  
  const finalPrompt = customInstructions 
    ? `${basePrompt}. ${customInstructions}`
    : basePrompt;

  const promptMessages = [
    {
      role: 'system',
      content: finalPrompt,
    },
  ];

  const body = {
    model: 'gpt-5-nano',
    messages: promptMessages,

  };

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify(body),
    signal: abortSignal,
  });

  if (!response.ok) {
    const errorData = await response.json();
    if (errorData && errorData.error) {
      const errorMessage = formatOpenAIErrorMessage(errorData);

      // Cache quota exceeded errors to prevent spam
      if (errorData.error.code === 'insufficient_quota' || response.status === 429) {
        cacheQuotaExceededError(errorMessage);
      }

      tracker.errorRequest(requestId);
      throw new Error(errorMessage);
    }
    tracker.errorRequest(requestId);
    throw new Error(`Could not generate image description. OpenAI API error: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  const description = data.choices[0]?.message?.content?.trim() ?? '';

  if (!description) {
    tracker.errorRequest(requestId);
    throw new Error("Could not generate a valid image description. Please try again.");
  }

  tracker.completeRequest(requestId);
  return description;
} catch (error) {
  console.error('Error during getting description image:', error);
  tracker.errorRequest(requestId);
  throw error;
}

const getImageUrlRequest = async (
  openai: OpenAI,
  description: string,
  customInstructions: string = ''
): Promise<string | null> => {
  // Track API request
  const tracker = getGlobalApiTracker();
  const requestId = tracker.startRequest(
    'generate-image',
    `Generating image with DALL-E`,
    'üñºÔ∏è',
    '#6366F1'
  );

  try {
    tracker.setInProgress(requestId);

    const finalDescription = customInstructions
      ? `${description}. ${customInstructions}`
      : description;
      
    const response = await openai.images.generate({
      prompt: finalDescription,
      n: 1,
      size: '512x512',
      response_format: 'url',
    });

    if (!response.data || !response.data[0]?.url) {
      tracker.errorRequest(requestId);
      throw new Error("OpenAI did not return an image URL. Please try again.");
    }

    tracker.completeRequest(requestId);
    return response.data[0].url;
  } catch (error) {
    console.error('Error during image generation:', error);
    tracker.errorRequest(requestId);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—à–∏–±–∫–µ
    if (error instanceof Error) {
      const errorMessage = error.message || '';
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏ OpenAI
      if (errorMessage.includes('quota') || errorMessage.includes('billing')) {
        const quotaError = "Your OpenAI account has exceeded its quota.\n\nPlease check your billing details or use a different API key.";
        cacheQuotaExceededError(quotaError);
        throw new Error(quotaError);
      }
      
      if (errorMessage.includes('rate limit')) {
        throw new Error("OpenAI rate limit exceeded.\n\nPlease try again in a few minutes.");
      }
      
      if (errorMessage.includes('invalid API key')) {
        throw new Error("Invalid OpenAI API key.\n\nPlease check your API key in settings.");
      }
      
      // –î–ª—è –æ—à–∏–±–æ–∫, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –º–æ–¥–µ—Ä–∞—Ü–∏–µ–π –∫–æ–Ω—Ç–µ–Ω—Ç–∞
      if (errorMessage.includes('moderation') || errorMessage.includes('policy')) {
        throw new Error("OpenAI content policy violation.\n\nThe image request was flagged for content policy violation. Please modify your request.");
      }
      
      // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç JSON —Å –¥–µ—Ç–∞–ª—è–º–∏
      if (errorMessage.includes('{') && errorMessage.includes('}')) {
        try {
          // –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å JSON –∏–∑ —Å—Ç—Ä–æ–∫–∏ –æ—à–∏–±–∫–∏
          const jsonStr = errorMessage.substring(
            errorMessage.indexOf('{'),
            errorMessage.lastIndexOf('}') + 1
          );
          const errorData = JSON.parse(jsonStr);
          if (errorData && errorData.error) {
            return formatOpenAIErrorMessage(errorData);
          }
        } catch (jsonError) {
          // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å JSON, –ø—Ä–æ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        }
      }
      
      throw error; // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é –æ—à–∏–±–∫—É, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –ø–æ–¥ –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —à–∞–±–ª–æ–Ω—ã
    }
    
    throw new Error("Failed to generate image.\n\nPlease check your OpenAI API key and try again.");
  }
};

export const getOpenAiImageUrl = async (
  openai: OpenAI,
  apiKey: string,
  word: string,
  customInstructions: string = ''
): Promise<string | null> => {
    // Track API request
    const tracker = getGlobalApiTracker();
    const requestId = tracker.startRequest(
      'generate-image',
      `Generating image for "${word}"`,
      'üñºÔ∏è',
      '#6366F1'
    );

    try {
        if (!apiKey) {
          tracker.errorRequest(requestId);
          throw new Error("OpenAI API key is missing. Please check your settings.");
        }

        tracker.setInProgress(requestId);

        // Check if we recently got a quota exceeded error
        if (isQuotaExceededCached()) {
          tracker.errorRequest(requestId);
          throw new Error(quotaExceededCache!.message);
        }
    
        const isAbstractWord = await isAbstract(apiKey, word);

    if (isAbstractWord) {
        const description = await getDescriptionImage(apiKey, word, customInstructions);
        const result = await getImageUrlRequest(
            openai,
            `Create a vivid, high-quality illustration representing the concept of '${description}'`,
            customInstructions
        );
        tracker.completeRequest(requestId);
        return result;
    } else {
        const photorealisticPrompt = `Create a high-quality, photorealistic image of a ${word} with a neutral expression and clear features`;
        const result = await getImageUrlRequest(openai, photorealisticPrompt, customInstructions);
        tracker.completeRequest(requestId);
        return result;
    }
} catch (error) {
    console.error('Error during getting image for word:', error);
    tracker.errorRequest(requestId);
    throw error;
}

const getLangaugeNameText = async (
  apiKey: string,
  text: string
): Promise<string | null> => {
  // Track API request
  const tracker = getGlobalApiTracker();
  const requestId = tracker.startRequest(
    'detect-language',
    `Detecting language of text`,
    'üî§',
    '#8B5CF6'
  );

  try {
    if (!apiKey) {
      tracker.errorRequest(requestId);
      throw new Error("OpenAI API key is missing. Please check your settings.");
    }

    tracker.setInProgress(requestId);

    // Check if we recently got a quota exceeded error
    if (isQuotaExceededCached()) {
      tracker.errorRequest(requestId);
      throw new Error(quotaExceededCache!.message);
    }
  
  const body = {
    model: 'gpt-5-nano',
    messages: [
      { role: 'system', content: 'You are langauage expert' },
      {
        role: 'user',
        content: `What is the name of this language: ${text}. Give only name of this language in one word`,
      },
    ],

  };

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify(body),
    signal: undefined, // AbortSignal not available in this internal function
  });

    if (!response.ok) {
      const errorData = await response.json();
      if (errorData && errorData.error) {
        const errorMessage = formatOpenAIErrorMessage(errorData);
        
        // Cache quota exceeded errors to prevent spam
        if (errorData.error.code === 'insufficient_quota' || response.status === 429) {
          cacheQuotaExceededError(errorMessage);
        }
        
        throw new Error(errorMessage);
      }
      throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    tracker.completeRequest(requestId);
    return data.choices[0]?.message?.content?.trim() ?? null;
  } catch (error) {
    console.error('Error during language name detection:', error);
    tracker.errorRequest(requestId);
    throw error; // Propagate error instead of returning null
  }
};

export const generateAnkiFront = async (
  apiKey: string,
  text: string,
  abortSignal?: AbortSignal
): Promise<string | null> => {
  // Track API request
  const tracker = getGlobalApiTracker();
  const requestId = tracker.startRequest(
    'create-card',
    `Generating question for card front`,
    '‚ùì',
    '#10B981'
  );

  try {
    if (!apiKey) {
      tracker.errorRequest(requestId);
      throw new Error("OpenAI API key is missing. Please check your settings.");
    }

    tracker.setInProgress(requestId);

    // Check if we recently got a quota exceeded error
    if (isQuotaExceededCached()) {
      tracker.errorRequest(requestId);
      throw new Error(quotaExceededCache!.message);
    }
  
  const langauage = await getLangaugeNameText(apiKey, text);

  const body = {
    model: 'gpt-5-nano',
    messages: [
      {
        role: 'system',
        content: `You generate a question based on the text entered. You answer should be in ${langauage}`,
      },
      {
        role: 'user',
        content: `Give a main question of this text: ${text}'. You answer should be in ${langauage}`,
      },
    ],

  };

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify(body),
    signal: abortSignal,
  });

    const data = await response.json();
    tracker.completeRequest(requestId);
    return data.choices[0]?.message?.content?.trim() ?? null;
  } catch (error) {
    console.error(
      'Error during generating front side of the Anki card:',
      error
    );
    tracker.errorRequest(requestId);
    return null;
  }
};

export const generateAnkiBack = async (
  apiKey: string,
  text: string
): Promise<string | null> => {
  // Track API request
  const tracker = getGlobalApiTracker();
  const requestId = tracker.startRequest(
    'create-card',
    `Generating answer for card back`,
    'üìñ',
    '#F59E0B'
  );

  try {
    if (!apiKey) {
      tracker.errorRequest(requestId);
      throw new Error("OpenAI API key is missing. Please check your settings.");
    }

    tracker.setInProgress(requestId);

    // Check if we recently got a quota exceeded error
    if (isQuotaExceededCached()) {
      tracker.errorRequest(requestId);
      throw new Error(quotaExceededCache!.message);
    }
  
  const langauage = await getLangaugeNameText(apiKey, text);

  const body = {
    model: 'gpt-5-nano',
    messages: [
      {
        role: 'system',
        content: `You generate a key point based on the text entered. For back of flash card. You answer should be in ${langauage}`,
      },
      {
        role: 'user',
        content: `Anilize text. Highlight the key points from this text. Put them in a list of senteses with dash points.
                                Text: '${text}'. You answer should be in ${langauage}. Key points should be competed and make sence`,
      },
    ],

  };

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify(body),
    signal: undefined, // AbortSignal not available in this function
  });

    const data = await response.json();
    tracker.completeRequest(requestId);
    return data.choices[0]?.message?.content?.trim() ?? null;
  } catch (error) {
    console.error('Error during generating back side of the Anki card:', error);
    tracker.errorRequest(requestId);
    return null;
  }
};
